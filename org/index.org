#+TITLE: sqrt-data
#+PROPERTY: header-args:python :comments link
#+PROPERTY: PRJ-DIR ..
#+HUGO_ALIASES: /sqrt-data

[[https://forthebadge.com/images/badges/works-on-my-machine.svg]]

This is an agglomeration of self-quantification scripts I've written over the years.

The basic ideas are as follows:
- I don't want to do a lot of (or any) manual work to collect the data. I'd rather have tools collect statistics in background so I could process them later.
- The tools have to be able to give away the data in machine-readable formats.
- Wherever possible, I want to own my data.

It's unlikely that you'll be to run the project as it is, as it's tuned pretty closely to my particular workflows and needs (hence the badge). Nevertheless, you may find something useful here.

The project is written with [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] paradigm with Emacs' [[https://orgmode.org/worg/org-contrib/babel/intro.html][Org Mode]] as a backend. This file contains basic information and common logic, necessary for the individual components.

* Architecture
TODO

* Python CLI
** Common API
This is my preferred way of writing Python modules. The =__init__.py= file imports all the required files with a star import, and the those files have the exported entities in the =__all__= variable.

That way I can import things like this: =from sqrt_data.api import settings=.

#+begin_src python :tangle (my/org-prj-dir "sqrt_data/api/__init__.py")
from .config import *
from .db import *
from .hash import *
#+end_src

*** Configuration
Let's start with configuration.

My configuration library of choice for Python is [[https://github.com/rochacbruno/dynaconf][dynaconf]]. I like it because it allows for some simple logic in the config files, e.g. dynamic variables.

#+begin_src python :tangle (my/org-prj-dir "sqrt_data/api/config.py")
import os

from dynaconf import Dynaconf

__all__ = ['settings']

settings = Dynaconf(
    settings_files=[
        'config.toml',
        os.path.expanduser('~/.config/sqrt-data/config.toml')
    ],
)
#+end_src

| Type | Note                                       |
|------+--------------------------------------------|
| TODO | Demarcate this block with links to modules |

#+begin_src conf-toml :tangle (my/org-prj-dir "config.toml")
[database]
user = 'postgres'
password = 'localdbpass'
database = 'data'
host = 'localhost'
port = 5432

[general]
root = '@format {env[HOME]}/logs-sync-debug'
hash_json = '@format {this.general.root}/hash.json'
hash_db = '@format {this.general.root}/hash.db'
temp_data_folder = '/tmp/sqrt-data'

[archive]
days = 31
timeout = 5

[mpd]
library_csv = '@format {this.general.root}/mpd/mpd_library.csv'
log_folder = '@format {this.general.root}/mpd/logs'

[waka]
api_key = 'dummy'
api_url = 'https://wakatime.com/api/v1'
schema = 'wakatime'

[aw]
aw_last_updated = '@format {this.general.root}/aw_last_updated.json'
aw_logs_folder = '@format {this.general.root}/aw'
aw_types = ['afkstatus', 'currentwindow']

[google]
android_file = '@format {this.general.root}/google/android-history.json'
android_schema = 'android'

[vk]
author = 'Pavel Korytov'
schema = 'vk'

[sleep]
file = '@format {this.general.root}/sleep/sleep-export.csv'
schema = 'sleep'

[sleep.geos]
e3336012 = 'test'
#+end_src
*** Database
My favorite Python ORM framework is [[https://www.sqlalchemy.org/][SQLAlchemy]]. I've started this project before the 2.0 version was announced, so some of the usage may reflect the old patterns.

Also, I am using some actual ORM models here, but wherever I can, I trust pandas to manage tables for me.

I have a bunch of options of writing such files:
- if I use noweb, I can't use =M-x org-babel-detangle=
- if I write one huge block, I can't interweave the code with comments
- if I write small blocks, blocks with class methods would have to be indented and I can't use =C-c '=

So I opt for noweb. Fortunately, this seems to be the only class in the entire project, because I adopted it from another project which was designed with Object-Oriented Paradigm in mind.

This class stores the state in the class variables and all of its methods are static, so really it's nothing more than an aggregation of global variables. Now I'd make it singleton if I were to design this from scratch, but hey, it works.

#+begin_src python :noweb yes :tangle (my/org-prj-dir "sqrt_data/api/db.py")
import logging
from contextlib import contextmanager
from sqlalchemy import create_engine
from sqlalchemy.orm import scoped_session, sessionmaker

from .config import settings

__all__ = ['DBConn']


class DBConn:
    engine = None
    Session = None
    Base = None

    <<db-dbconn>>
#+end_src

A "constructor", which just sets up a bunch of class variables. This has to be called in before any call to the database.
#+begin_src python :noweb-ref db-dbconn :tangle no
def __init__(self, **kwargs):
    DBConn.engine = DBConn.get_engine(**kwargs)
    DBConn.Session = sessionmaker()
    DBConn.Session.configure(bind=self.engine)
    DBConn.scoped_session = scoped_session(DBConn.Session)
    logging.info('Initialized database connection')
#+end_src

A method to reset the class, just in case. The original project used this for unit tests, but I don't plan to implement unit tests here as of now.

#+begin_src python :noweb-ref db-dbconn :tangle no
@classmethod
def reset(cls):
    cls.engine = cls.Session = None
#+end_src

A method to get a database session object. In SQLAlchemy this seems to create transactions in the background, that is you can run =commit()=, =rollback()= and all that good stuff. By default, this commits automatically.
#+begin_src python :noweb-ref db-dbconn :tangle no
@staticmethod
@contextmanager
def get_session(**kwargs):
    session = DBConn.Session(**kwargs)
    yield session
    session.close()
#+end_src

The usage of the above methods is as follows:
#+begin_src python :tangle no
with DBConn.get_session() as db:
    db.<do-stuff>
#+end_src

A similar method, which can be used to ensure that a session exists.
#+begin_src python :noweb-ref db-dbconn :tangle no
@staticmethod
@contextmanager
def ensure_session(session, **kwargs):
    if session is None:
        session = DBConn.Session(**kwargs)
        yield session
        session.close()
    else:
        yield session
#+end_src

A method to get a fresh database engine. This object can be passed to pandas.
#+begin_src python :noweb-ref db-dbconn :tangle no
@staticmethod
def get_engine(user=None, password=None, **kwargs):
    url = "postgresql://{0}:{1}@{2}:{3}/{4}".format(
        user or settings.database.user, password or settings.database.password,
        settings.database.host, settings.database.port,
        settings.database.database
    )
    return create_engine(url, **kwargs)
#+end_src

Finally, a method to create tables in a schema.
#+begin_src python :noweb-ref db-dbconn :tangle no
@staticmethod
def create_schema(schema, Base=None):
    DBConn.engine.execute(f'CREATE SCHEMA IF NOT EXISTS {schema}')
    if Base is not None:
        tables = []
        for name, table in Base.metadata.tables.items():
            if table.schema == schema:
                tables.append(table)
        Base.metadata.create_all(DBConn.engine, tables)
#+end_src
*** Hashes
:PROPERTIES:
:header-args:python+: :tangle (my/org-prj-dir "sqrt_data/api/hash.py")
:END:

Another common thing I need is to track changes within files. The obvious way to do that is to compare hashes of files.
#+begin_src python
from sqlitedict import SqliteDict
import logging
import os
import subprocess
from .config import settings

__all__ = ['md5sum', 'HashDict']
#+end_src

So, first we need to calculate a hash.
#+begin_src python
def md5sum(filename):
    res = subprocess.run(
        ['md5sum', filename],
        capture_output=True,
        check=True,
        cwd=settings.general.root
    ).stdout
    res = res.decode('utf-8')
    return res.split(' ')[0]
#+end_src

Second, how do we actually store the hashes? I was using a huge JSON file for some time, but during the refactoring I've came to an idea that something like SQLite would make more sense. [[https://github.com/RaRe-Technologies/sqlitedict][SqliteDict]] seems to be a reasonable wrapper which does exactly what I want, so I'll use that as a base.

One note here is that the module crashes with message that =libgcc_s.so.1= cannot be found, which seems to be a problem with my Anaconda + Guix setup. [[https://stackoverflow.com/questions/64797838/libgcc-s-so-1-must-be-installed-for-pthread-cancel-to-work][This answer]] on StackOverflow has helped.
#+begin_src python
import ctypes
libgcc_s = ctypes.CDLL('libgcc_s.so.1')
#+end_src

Now, the class:
#+begin_src python
class HashDict(SqliteDict):
    def __init__(self, *args, **kwargs):
        super().__init__(settings.general.hash_db, *args, **kwargs)

    def is_updated(self, filename):
        saved = self.get(filename)
        return saved is None or saved != md5sum(filename)

    def save_hash(self, filename):
        self[filename] = md5sum(filename)

    def toggle_hash(self, filename):
        if self.is_updated(filename):
            self.save_hash(filename)
        else:
            self[filename] = '0'

    def report(self):
        for name, value in self.items():
            if os.path.exists(name):
                if self.is_updated(name):
                    print('[UPD]\t', end='')
                else:
                    print('[   ]\t', end='')
            else:
                print('[DEL]\t', end='')
            print(f"{value}\t{name}")
#+end_src
** CLI entrypoint
:PROPERTIES:
:header-args:python+: :tangle (my/org-prj-dir "sqrt_data/manage.py")
:END:
We need an entrypoint for the CLI. My CLI library of choice is [[https://click.palletsprojects.com/en/8.0.x/][click]].

Also, [[https://github.com/magmax/python-inquirer][python-inquirer]] is nice library to query the user for something.
#+begin_src python
import logging

import click
import os
import inquirer

from sqrt_data.api import HashDict, settings
from sqrt_data import cli as cli_modules
#+end_src

A simple logging setup.
#+begin_src python
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
    handlers=[logging.FileHandler('./cli.log'),
              logging.StreamHandler()]
)
#+end_src

Initialize a click group.
#+begin_src python
@click.group()
def cli():
    print(f'CWD: {os.getcwd()}')
#+end_src

Add all the components to the group.
#+begin_src python
cli.add_command(cli_modules.waka)
cli.add_command(cli_modules.android)
cli.add_command(cli_modules.vk)
cli.add_command(cli_modules.sleep)
cli.add_command(cli_modules.mpd)
#+end_src

The corresponding =__init__.py= in the CLI module:
#+begin_src python :tangle (my/org-prj-dir "sqrt_data/cli/__init__.py")
from .android import *
from .waka import *
from .vk import *
from .sleep import *
from .mpd import *
#+end_src

Two simple commands to work with file hashes.
#+begin_src python
@cli.command()
def hash_list():
    hashes = HashDict()
    hashes.report()

@cli.command()
@click.option('-n', '--name', required=False, type=str)
def hash_toggle(name):
    with HashDict() as h:
        if name is None:
            name = inquirer.prompt(
                [inquirer.List('filename', 'Select filename', h.keys())]
            )['filename']  # type: ignore
        h.toggle_hash(os.path.join(settings.general.root, name))
        logging.info('Toggled hash for %s', name)
        h.commit()
#+end_src

Finally, to make this work, we have to invoke =cli()= in case =manage.py= is the main module. That is, when invoked with =python -m sqrt_data.manage=.
#+begin_src python
if __name__ == '__main__':
    cli()
#+end_src

To be able to invoke the app with =python -m sqrt_data=, the following =__main__.py= is necessary:
#+begin_src python :tangle (my/org-prj-dir "sqrt_data/__main__.py")
from .manage import cli

if __name__ == '__main__':
    cli()
#+end_src
** Misc
*** setup.py and requirements
#+begin_src python :tangle (my/org-prj-dir "setup.py")
from setuptools import find_packages, setup

setup(
    name='sqrt_data',
    version='2.0.1',
    description=
    'A collection of scripts to gather various data from my machines and store it on my VPS',
    author='SqrtMinusOne',
    author_email='thexcloud@gmail.com',
    packages=find_packages(),
    install_requires=[
        'pandas', 'numpy', 'click', 'inquirer', 'python-mpd2', 'sqlalchemy',
        'psycopg2-binary', 'requests', 'tqdm', 'beautifulsoup4'
    ],
    entry_points='''
    [console_scripts]
    sqrt_data=sqrt_data.manage:cli
    ''')
#+end_src

#+begin_src text :tangle (my/org-prj-dir "requirements.txt")
pandas
python-mpd2
sqlalchemy
psycopg2
#+end_src
* Notes
** Android setup
Add to =.bashrc=:
#+begin_src bash
export ANDROID_PHONE="orchid"
#+end_src
